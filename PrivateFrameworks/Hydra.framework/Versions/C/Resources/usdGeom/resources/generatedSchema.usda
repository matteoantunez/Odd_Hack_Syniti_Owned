#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
    customLayerData = {
        string[] appliedAPISchemas = ["GeomModelAPI", "MotionAPI"]
        dictionary multipleApplyAPISchemas = {
        }
    }
)

class "Imageable" (
    )
{
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
}

class "PrimvarsAPI" (
    )
{
}

class "Xformable" (
    )
{
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Scope "Scope" (
    )
{
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
}

class Xform "Xform" (
    
)
{
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class "Boundable" (
    )
{
    float3[] extent (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class "Gprim" (
    )
{
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Cube "Cube" (
    )
{
    uniform bool doubleSided = 0 (
            )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double size = 2 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Sphere "Sphere" (
    )
{
    uniform bool doubleSided = 0 (
            )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double radius = 1 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Cylinder "Cylinder" (
    )
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        
    )
    uniform bool doubleSided = 0 (
            )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
            )
    double height = 2 (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double radius = 1 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Capsule "Capsule" (
    )
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        
    )
    uniform bool doubleSided = 0 (
            )
    float3[] extent = [(-0.5, -0.5, -1), (0.5, 0.5, 1)] (
            )
    double height = 1 (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double radius = 0.5 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Cone "Cone" (
    )
{
    uniform token axis = "Z" (
        allowedTokens = ["X", "Y", "Z"]
        
    )
    uniform bool doubleSided = 0 (
            )
    float3[] extent = [(-1, -1, -1), (1, 1, 1)] (
            )
    double height = 2 (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double radius = 1 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class "PointBased" (
    )
{
    vector3f[] accelerations (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Mesh "Mesh" (
    )
{
    vector3f[] accelerations (
            )
    int[] cornerIndices = [] (
            )
    float[] cornerSharpnesses = [] (
            )
    int[] creaseIndices = [] (
            )
    int[] creaseLengths = [] (
            )
    float[] creaseSharpnesses = [] (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    token faceVaryingLinearInterpolation = "cornersPlus1" (
        allowedTokens = ["none", "cornersOnly", "cornersPlus1", "cornersPlus2", "boundaries", "all"]
            )
    int[] faceVertexCounts (
            )
    int[] faceVertexIndices (
            )
    int[] holeIndices = [] (
            )
    token interpolateBoundary = "edgeAndCorner" (
        allowedTokens = ["none", "edgeOnly", "edgeAndCorner"]
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    uniform token subdivisionScheme = "catmullClark" (
        allowedTokens = ["catmullClark", "loop", "bilinear", "none"]
            )
    token triangleSubdivisionRule = "catmullClark" (
        allowedTokens = ["catmullClark", "smooth"]
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class GeomSubset "GeomSubset" (
    )
{
    uniform token elementType = "face" (
        allowedTokens = ["face"]
            )
    uniform token familyName = "" (
            )
    int[] indices = [] (
            )
}

class NurbsPatch "NurbsPatch" (
    )
{
    vector3f[] accelerations (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    double[] pointWeights (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    int[] trimCurve:counts (
            )
    double[] trimCurve:knots (
            )
    int[] trimCurve:orders (
        
    )
    double3[] trimCurve:points (
            )
    double2[] trimCurve:ranges (
            )
    int[] trimCurve:vertexCounts (
            )
    uniform token uForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
            )
    double[] uKnots (
            )
    int uOrder (
            )
    double2 uRange (
            )
    int uVertexCount (
            )
    vector3f[] velocities (
            )
    uniform token vForm = "open" (
        allowedTokens = ["open", "closed", "periodic"]
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    double[] vKnots (
            )
    int vOrder (
            )
    double2 vRange (
            )
    int vVertexCount (
            )
    uniform token[] xformOpOrder (
            )
}

class "Curves" (
    )
{
    vector3f[] accelerations (
            )
    int[] curveVertexCounts (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    float[] widths (
            )
    uniform token[] xformOpOrder (
            )
}

class BasisCurves "BasisCurves" (
    )
{
    vector3f[] accelerations (
            )
    uniform token basis = "bezier" (
        allowedTokens = ["bezier", "bspline", "catmullRom"]
            )
    int[] curveVertexCounts (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    uniform token type = "cubic" (
        allowedTokens = ["linear", "cubic"]
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    float[] widths (
            )
    uniform token wrap = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
            )
    uniform token[] xformOpOrder (
            )
}

class NurbsCurves "NurbsCurves" (
    )
{
    vector3f[] accelerations (
            )
    int[] curveVertexCounts (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    double[] knots (
            )
    normal3f[] normals (
            )
    int[] order = [] (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double2[] ranges (
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    float[] widths (
            )
    uniform token[] xformOpOrder (
            )
}

class Points "Points" (
    )
{
    vector3f[] accelerations (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    int64[] ids (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    float[] widths (
            )
    uniform token[] xformOpOrder (
            )
}

class PointInstancer "PointInstancer" (
    )
{
    vector3f[] accelerations (
            )
    vector3f[] angularVelocities (
            )
    float3[] extent (
            )
    int64[] ids (
            )
    int64[] invisibleIds = [] (
            )
    quath[] orientations (
            )
    point3f[] positions (
            )
    int[] protoIndices (
            )
    rel prototypes (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    float3[] scales (
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class Camera "Camera" (
    )
{
    float4[] clippingPlanes = [] (
            )
    float2 clippingRange = (1, 1000000) (
            )
    float exposure = 0 (
            )
    float focalLength = 50 (
            )
    float focusDistance = 0 (
            )
    float fStop = 0 (
        
    )
    float horizontalAperture = 20.955 (
            )
    float horizontalApertureOffset = 0 (
            )
    token projection = "perspective" (
        allowedTokens = ["perspective", "orthographic"]
    )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    double shutter:close = 0 (
            )
    double shutter:open = 0 (
            )
    uniform token stereoRole = "mono" (
        allowedTokens = ["mono", "left", "right"]
            )
    float verticalAperture = 15.2908 (
            )
    float verticalApertureOffset = 0 (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    uniform token[] xformOpOrder (
            )
}

class "GeomModelAPI" (
    )
{
    uniform bool model:applyDrawMode = 0 (
            )
    uniform token model:cardGeometry = "cross" (
        allowedTokens = ["cross", "box", "fromTexture"]
            )
    asset model:cardTextureXNeg (
            )
    asset model:cardTextureXPos (
            )
    asset model:cardTextureYNeg (
            )
    asset model:cardTextureYPos (
            )
    asset model:cardTextureZNeg (
            )
    asset model:cardTextureZPos (
            )
    uniform token model:drawMode = "inherited" (
        allowedTokens = ["origin", "bounds", "cards", "default", "inherited"]
            )
    uniform float3 model:drawModeColor = (0.18, 0.18, 0.18) (
            )
}

class "MotionAPI" (
    )
{
    float motion:velocityScale = 1 (
            )
}

class "XformCommonAPI" (
    )
{
}

class HermiteCurves "HermiteCurves" (
    )
{
    vector3f[] accelerations (
            )
    int[] curveVertexCounts (
            )
    uniform bool doubleSided = 0 (
            )
    float3[] extent (
            )
    normal3f[] normals (
            )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
            )
    point3f[] points (
            )
    color3f[] primvars:displayColor (
            )
    float[] primvars:displayOpacity (
            )
    rel proxyPrim (
            )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
            )
    vector3f[] tangents = [] (
            )
    vector3f[] velocities (
            )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
            )
    float[] widths (
            )
    uniform token[] xformOpOrder (
            )
}

